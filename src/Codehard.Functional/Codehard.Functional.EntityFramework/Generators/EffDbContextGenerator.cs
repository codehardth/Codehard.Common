using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Codehard.Functional.EntityFramework.Generators;

/// <summary>
/// This class is responsible for generating DbContext classes for Entity Framework.
/// It implements the IIncrementalGenerator interface which is used for source generation in .NET.
/// </summary>
[Generator]
public class EffDbContextGenerator  : IIncrementalGenerator
{
    /// <summary>
    /// This method is called when the generator is initialized.
    /// It sets up the incremental generation pipeline.
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Create a syntax provider that will find all DbContext classes in the compilation.
        var dbContextTargets =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => node is CompilationUnitSyntax cus && IsContainsDbContext(cus),
                    transform: static (context, _) => (CompilationUnitSyntax)context.Node)
                .Collect();
        
        // Register a source output that will generate the EffDbContext classes.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(dbContextTargets),
            (spc, source) => Execute(source.Left, source.Right, spc));

        return;
        
        static bool IsInheritDbContext(ClassDeclarationSyntax cds) =>
            cds.BaseList?.Types.Any(t => t.ToString() == "DbContext") == true;
        
        static bool IsContainsDbContext(CompilationUnitSyntax cus) =>
            cus.DescendantNodes().OfType<ClassDeclarationSyntax>().Any(IsInheritDbContext);
    }
    
    /// <summary>
    /// This method is called for each DbContext class that was found.
    /// It generates the source code for the DbContext class.
    /// </summary>
    private static void Execute(
        Compilation compilation,
        ImmutableArray<CompilationUnitSyntax> compilationUnitSyntaxes,
        SourceProductionContext context)
    {
        static bool IsInheritDbContext(ClassDeclarationSyntax cds) =>
            cds.BaseList?.Types.Any(t => t.ToString() == "DbContext") == true;

        static IEnumerable<ClassDeclarationSyntax> GetDbContextClasses(CompilationUnitSyntax cus) =>
            cus.DescendantNodes().OfType<ClassDeclarationSyntax>().Where(IsInheritDbContext);
        
        // Iterate over each DbContext class.
        foreach (var cus in compilationUnitSyntaxes)
        {
            var usings = cus.Usings;
            var dbContextClasses = GetDbContextClasses(cus);    
            
            // Extract the namespaces from the using directives.
            var namespaces =
                usings
                    .Where(u => u.Name != null)
                    .Select(u => $"using {u.Name!.ToString()};")
                    .ToHashSet();

            foreach (var dbContextClass in dbContextClasses)
            {
                var dbContextNamespace =
                    SourceReader.GetNamespace(dbContextClass) ?? SourceReader.GetFileScopedNamespace(cus);
                
                if(dbContextNamespace is null) continue;

                GenEffDbContext(namespaces, dbContextClass, dbContextNamespace);
            }
        }

        return;

        void GenEffDbContext(
            IEnumerable<string> namespaces,
            ClassDeclarationSyntax dbContext,
            string dbContextNamespace)
        {
            // Get the base type of the DbContext class.
            var baseTypeSyntax = dbContext.BaseList?.Types.FirstOrDefault();
            IEnumerable<IMethodSymbol>? baseTypeMethodSymbols = null;
            
            // If the base type exists, get its methods.
            if (baseTypeSyntax != null)
            {
                var semanticModel = compilation.GetSemanticModel(dbContext.SyntaxTree);

                if (semanticModel.GetSymbolInfo(baseTypeSyntax.Type).Symbol is INamedTypeSymbol baseTypeSymbol)
                {
                    baseTypeMethodSymbols = baseTypeSymbol.GetMembers().OfType<IMethodSymbol>();
                }
            }
            
            // Generate the source code for the DbContext class.
            var code =
                $@"// <auto-generated />
#nullable enable

using LanguageExt;
using static LanguageExt.Prelude;

{string.Join("\n", namespaces)}
using Microsoft.EntityFrameworkCore.ChangeTracking;

namespace {dbContextNamespace};

public readonly struct Eff{dbContext.Identifier}
{{
    private readonly {dbContext.Identifier} dbContext;

    public Eff{dbContext.Identifier}({dbContext.Identifier} dbContext)
    {{
        this.dbContext = dbContext;
    }}

    // Effect implementation for {dbContext.Identifier}
    {string.Join("\n\n    ", GenMethods(dbContext.Members))}

    // Effect implementation for DbContext
    {(baseTypeMethodSymbols is null ? default : string.Join("\n\n    ", GenMethodsFromSymbols(baseTypeMethodSymbols)))}
}}";

            context.AddSource($"Eff{dbContext.Identifier}.g", code);
        }

        IEnumerable<string?> GenMethods(SyntaxList<MemberDeclarationSyntax> members)
        {
            foreach (var method
                     in members.OfType<MethodDeclarationSyntax>()
                               .Where(m =>
                                   m.Modifiers.Any(modifier =>
                                       modifier.IsKind(SyntaxKind.PublicKeyword))))
            {
                context.CancellationToken.ThrowIfCancellationRequested();
                
                var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);
                var returnTypeSymbol = semanticModel.GetTypeInfo(method.ReturnType).Type;
                var taskSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task");
                var taskOfTSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task`1");
                var valueTaskOfTSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.ValueTask`1");
                
                if (returnTypeSymbol!.OriginalDefinition.Equals(
                        taskSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateTaskUnitMethod(method)}";
                }
                else if (returnTypeSymbol.OriginalDefinition.Equals(
                             taskOfTSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateTaskOfTMethod(method)}";
                }
                else if (returnTypeSymbol.OriginalDefinition.Equals(
                             valueTaskOfTSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateTaskOfTMethod(method)}";
                }
            }
        }
        
        static string CreateTaskUnitMethod(MethodDeclarationSyntax method)
        {
            var declarationParameters = SourceReader.GetMethodDeclarationParameters(method);
            var parameters = SourceReader.GetMethodCallParameters(method);
            var methodGenericParameters = SourceReader.GetMethodGenericParameters(method);
            
            return
                $"Aff<Unit> {method.Identifier}{methodGenericParameters}({declarationParameters})" + "\n" +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Aff(async () => {{ await self.dbContext.{method.Identifier}" +
                $"({parameters}); return unit; }});" + "\n" +
                $"    }}";
        }
        
        string? CreateTaskOfTMethod(MethodDeclarationSyntax method)
        {
            var declarationParameters = SourceReader.GetMethodDeclarationParameters(method);
            var parameters = SourceReader.GetMethodCallParameters(method);
            var methodGenericParameters = SourceReader.GetMethodGenericParameters(method);
            
            var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);

            if (semanticModel.GetTypeInfo(method.ReturnType).Type
                is not INamedTypeSymbol
                {
                    IsGenericType: true, TypeArguments.Length: > 0
                } returnTypeSymbol)
            {
                return null;
            }
            
            var taskTypeArgument = returnTypeSymbol.TypeArguments[0];
            var taskTypeArgumentName = taskTypeArgument.Name; // This will be "T" for Task<T>
            
            // Check if taskTypeArgument is nullable
            if (taskTypeArgument.NullableAnnotation == NullableAnnotation.Annotated)
            {
                // If it is nullable, wrap it with Option
                taskTypeArgumentName = $"Option<{taskTypeArgumentName}>";
            }
                
            return
                $"Aff<{taskTypeArgumentName}> {method.Identifier}{methodGenericParameters}({declarationParameters})" + "\n" +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Aff<{taskTypeArgumentName}>(async () => await self.dbContext.{method.Identifier}({parameters}));" + "\n" +
                $"    }}";
        }
        
        IEnumerable<string?> GenMethodsFromSymbols(IEnumerable<IMethodSymbol> methods)
        {
            foreach (var method in methods)
            {
                if (method.DeclaredAccessibility != Accessibility.Public)
                {
                    continue;
                }
                
                var returnTypeSymbol = method.ReturnType;
                var taskSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task");
                var taskOfTSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task`1");
                var valueTaskOfTSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.ValueTask`1");

                if (returnTypeSymbol.OriginalDefinition.Equals(
                        taskSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateTaskUnitMethodFromSymbol(method)}";
                }
                else if (returnTypeSymbol.OriginalDefinition.Equals(
                             taskOfTSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateTaskOfTMethodFromSymbol(method)}";
                }
                else if (returnTypeSymbol.OriginalDefinition.Equals(
                             valueTaskOfTSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateTaskOfTMethodFromSymbol(method)}";
                }
            }
        }
        
        string CreateTaskUnitMethodFromSymbol(IMethodSymbol methodSymbol)
        {
            var declarationParameters = SymbolReader.GetMethodDeclarationParameters(methodSymbol);
            var parameters = SymbolReader.GetMethodCallParameters(methodSymbol);

            return
                $"Aff<Unit> {methodSymbol.Name}{SymbolReader.GetMethodGenericTypeParameters(methodSymbol)}" +
                $"({declarationParameters})" + "\n" +
                SymbolReader.GetMethodConstraints(methodSymbol) +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Aff(async () => {{ await self.dbContext.{methodSymbol.Name}" +
                $"{SymbolReader.GetMethodGenericTypeParameters(methodSymbol)}({parameters});" +
                $" return unit; }});" + "\n" +
                $"    }}";
        }
        
        string? CreateTaskOfTMethodFromSymbol(IMethodSymbol methodSymbol)
        {
            var declarationParameters = SymbolReader.GetMethodDeclarationParameters(methodSymbol);
            var parameters = SymbolReader.GetMethodCallParameters(methodSymbol);

            // Get the return type of the method
            var returnTypeSymbol = methodSymbol.ReturnType;
            
            if (returnTypeSymbol is not INamedTypeSymbol { TypeArguments.Length: > 0 } namedTypeSymbol) return null;
            var taskTypeArgument = namedTypeSymbol.TypeArguments[0];

            var taskTypeArgumentName =
                taskTypeArgument is INamedTypeSymbol { TypeArguments.Length: > 0 } taskTypeArgumentSymbol
                    ? SymbolReader.GetInnerGenericTypes(taskTypeArgumentSymbol)
                    : namedTypeSymbol.TypeArguments[0].Name; // This will be "T" for Task<T>
            
            // Check if taskTypeArgument is nullable
            if (taskTypeArgument.NullableAnnotation == NullableAnnotation.Annotated)
            {
                // If it is nullable, wrap it with Option
                taskTypeArgumentName = $"Option<{taskTypeArgumentName}>";
            }
            
            return
                $"Aff<{taskTypeArgumentName}> {methodSymbol.Name}" +
                $"{SymbolReader.GetMethodGenericTypeParameters(methodSymbol)}({declarationParameters})" + "\n" +
                SymbolReader.GetMethodConstraints(methodSymbol) +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Aff<{taskTypeArgumentName}>(async () => await self.dbContext.{methodSymbol.Name}" +
                $"{SymbolReader.GetMethodGenericTypeParameters(methodSymbol)}({parameters}));" + "\n" +
                $"    }}";
        }
    }
}