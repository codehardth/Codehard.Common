using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Codehard.Functional.EntityFramework.Generators;

/// <summary>
/// This class is responsible for generating DbContext classes for Entity Framework.
/// It implements the IIncrementalGenerator interface which is used for source generation in .NET.
/// </summary>
[Generator]
public class EffDbContextGenerator  : IIncrementalGenerator
{
    /// <summary>
    /// This method is called when the generator is initialized.
    /// It sets up the incremental generation pipeline.
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Create a syntax provider that will find all DbContext classes in the compilation.
        var dbContextTargets =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => node is CompilationUnitSyntax cus && IsContainsDbContext(cus),
                    transform: static (context, _) => (CompilationUnitSyntax)context.Node)
                .Collect();
        
        // Register a source output that will generate the EffDbContext classes.
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(dbContextTargets),
            (spc, source) => Execute(source.Left, source.Right, spc));

        return;
        
        static bool IsInheritDbContext(ClassDeclarationSyntax cds) =>
            cds.BaseList?.Types.Any(t => t.ToString() == "DbContext") == true;
        
        static bool IsContainsDbContext(CompilationUnitSyntax cus) =>
            cus.DescendantNodes().OfType<ClassDeclarationSyntax>().Any(IsInheritDbContext);
    }
    
    /// <summary>
    /// This method is called for each DbContext class that was found.
    /// It generates the source code for the DbContext class.
    /// </summary>
    private static void Execute(
        Compilation compilation,
        ImmutableArray<CompilationUnitSyntax> compilationUnitSyntaxes,
        SourceProductionContext context)
    {
        static bool IsInheritDbContext(ClassDeclarationSyntax cds) =>
            cds.BaseList?.Types.Any(t => t.ToString() == "DbContext") == true;

        static IEnumerable<ClassDeclarationSyntax> GetDbContextClasses(CompilationUnitSyntax cus) =>
            cus.DescendantNodes().OfType<ClassDeclarationSyntax>().Where(IsInheritDbContext);
        
        // Iterate over each DbContext class.
        foreach (var cus in compilationUnitSyntaxes)
        {
            var usings = cus.Usings;
            var dbContextClasses = GetDbContextClasses(cus);    
            
            // Extract the namespaces from the using directives.
            var namespaces =
                usings
                    .Where(u => u.Name != null)
                    .Select(u => $"using {u.Name!.ToString()};")
                    .ToHashSet();

            foreach (var dbContextClass in dbContextClasses)
            {
                var dbContextNamespace =
                    SourceReader.GetNamespace(dbContextClass) ?? SourceReader.GetFileScopedNamespace(cus);
                
                if(dbContextNamespace is null) continue;

                GenEffDbContext(namespaces, dbContextClass, dbContextNamespace);
            }
        }

        return;

        void GenEffDbContext(
            IEnumerable<string> namespaces,
            ClassDeclarationSyntax dbContext,
            string dbContextNamespace)
        {
            // Get the base type of the DbContext class.
            var baseTypeSyntax = dbContext.BaseList?.Types.FirstOrDefault();
            IEnumerable<IMethodSymbol>? baseTypeMethodSymbols = null;
            
            // If the base type exists, get its methods.
            if (baseTypeSyntax != null)
            {
                var semanticModel = compilation.GetSemanticModel(dbContext.SyntaxTree);

                if (semanticModel.GetSymbolInfo(baseTypeSyntax.Type).Symbol is INamedTypeSymbol baseTypeSymbol)
                {
                    baseTypeMethodSymbols = baseTypeSymbol.GetMembers().OfType<IMethodSymbol>();
                }
            }
            
            // Generate the source code for the DbContext class.
            var code =
                $@"// <auto-generated />
#nullable enable

using LanguageExt;
using static LanguageExt.Prelude;

{string.Join("\n", namespaces)}
using Microsoft.EntityFrameworkCore.ChangeTracking;

namespace {dbContextNamespace};

public readonly struct Eff{dbContext.Identifier}
{{
    private readonly {dbContext.Identifier} dbContext;

    public Eff{dbContext.Identifier}({dbContext.Identifier} dbContext)
    {{
        this.dbContext = dbContext;
    }}

    // Effect implementation for {dbContext.Identifier}
    {string.Join("\n\n    ", GenMethods(dbContext.Members))}

    // Effect implementation for DbContext
    {(baseTypeMethodSymbols is null ? default : string.Join("\n\n    ", GenMethodsFromSymbols(baseTypeMethodSymbols)))}

    // Override object methods
    public override string ToString()
    {{
        return dbContext.ToString();
    }}

    public override bool Equals(object? obj)
    {{
        if (obj is Eff{dbContext.Identifier} other)
        {{
            return Equals(dbContext, other.dbContext);
        }}

        if (obj is {dbContext.Identifier} otherDbContext)
        {{
            return Equals(dbContext, otherDbContext);
        }}
        return false;
    }}

    public override int GetHashCode()
    {{
        return dbContext.GetHashCode();
    }}
}}";

            context.AddSource($"Eff{dbContext.Identifier}.g", code);
        }

        IEnumerable<string?> GenMethods(SyntaxList<MemberDeclarationSyntax> members)
        {
            foreach (var method
                     in members.OfType<MethodDeclarationSyntax>()
                               .Where(m =>
                                   m.Modifiers.Any(modifier =>
                                       modifier.IsKind(SyntaxKind.PublicKeyword))))
            {
                context.CancellationToken.ThrowIfCancellationRequested();
                
                var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);
                var returnTypeSymbol = semanticModel.GetTypeInfo(method.ReturnType).Type;
                var taskSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task");
                var taskOfTSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task`1");
                var valueTaskSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.ValueTask");
                var valueTaskOfTSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.ValueTask`1");
                
                if (returnTypeSymbol!.OriginalDefinition.Equals(
                        taskSymbol, SymbolEqualityComparer.IncludeNullability) ||
                    returnTypeSymbol.OriginalDefinition.Equals(
                        valueTaskSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateTaskUnitMethod(method)}";
                }
                else if (returnTypeSymbol.OriginalDefinition.Equals(
                             taskOfTSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateTaskOfTMethod(method)}";
                }
                else if (returnTypeSymbol.OriginalDefinition.Equals(
                             valueTaskOfTSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateTaskOfTMethod(method)}";
                }
                else if (returnTypeSymbol.SpecialType == SpecialType.System_Void)
                {
                    yield return $"public {CreateEffUnitMethod(method)}";
                }
                else if (IsObjectMethod(method))
                {
                    
                }
                else
                {
                    yield return $"public {CreateNonTaskMethod(method)}";
                }
            }
        }
        
        bool IsObjectMethod(MethodDeclarationSyntax method)
        {
            var objectType = compilation.GetTypeByMetadataName("System.Object");
            var methodSymbol = objectType?.GetMembers(method.Identifier.Text).OfType<IMethodSymbol>().FirstOrDefault();
            return methodSymbol != null;
        }
        
        string CreateEffUnitMethod(MethodDeclarationSyntax method)
        {
            var declarationParameters = SourceReader.GetMethodDeclarationParameters(method);
            var parameters = SourceReader.GetMethodCallParameters(method);
            var methodGenericParameters = SourceReader.GetMethodGenericParameters(method);

            return
                $"Eff<Unit> {method.Identifier}{methodGenericParameters}({declarationParameters})" + "\n" +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Eff<Unit>(() => {{ self.dbContext.{method.Identifier}({parameters}); return unit; }});" + "\n" +
                $"    }}";
        }

        string CreateNonTaskMethod(MethodDeclarationSyntax method)
        {
            var declarationParameters = SourceReader.GetMethodDeclarationParameters(method);
            var parameters = SourceReader.GetMethodCallParameters(method);
            var methodGenericParameters = SourceReader.GetMethodGenericParameters(method);
            
            var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);
            var returnTypeSymbol = semanticModel.GetTypeInfo(method.ReturnType).Type;
            var returnTypeName = returnTypeSymbol!.ToString();
                
            return
                $"{returnTypeName} {method.Identifier}{methodGenericParameters}({declarationParameters})" + "\n" +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return self.dbContext.{method.Identifier}({parameters});" + "\n" +
                $"    }}";
        }

        static string CreateTaskUnitMethod(MethodDeclarationSyntax method)
        {
            var declarationParameters = SourceReader.GetMethodDeclarationParameters(method);
            var parameters = SourceReader.GetMethodCallParameters(method);
            var methodGenericParameters = SourceReader.GetMethodGenericParameters(method);
            
            return
                $"Aff<Unit> {method.Identifier}{methodGenericParameters}({declarationParameters})" + "\n" +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Aff(async () => {{ await self.dbContext.{method.Identifier}" +
                $"({parameters}); return unit; }});" + "\n" +
                $"    }}";
        }
        
        string? CreateTaskOfTMethod(MethodDeclarationSyntax method)
        {
            var declarationParameters = SourceReader.GetMethodDeclarationParameters(method);
            var parameters = SourceReader.GetMethodCallParameters(method);
            var methodGenericParameters = SourceReader.GetMethodGenericParameters(method);
            
            var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);

            if (semanticModel.GetTypeInfo(method.ReturnType).Type
                is not INamedTypeSymbol
                {
                    IsGenericType: true, TypeArguments.Length: > 0
                } returnTypeSymbol)
            {
                return null;
            }
            
            var taskTypeArgument = returnTypeSymbol.TypeArguments[0];
            var taskTypeArgumentName = taskTypeArgument.Name; // This will be "T" for Task<T>
            
            // Check if taskTypeArgument is nullable
            if (taskTypeArgument.NullableAnnotation == NullableAnnotation.Annotated)
            {
                // If it is nullable, wrap it with Option
                taskTypeArgumentName = $"Option<{taskTypeArgumentName}>";
            }
                
            return
                $"Aff<{taskTypeArgumentName}> {method.Identifier}{methodGenericParameters}({declarationParameters})" + "\n" +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Aff<{taskTypeArgumentName}>(async () => await self.dbContext.{method.Identifier}({parameters}));" + "\n" +
                $"    }}";
        }
        
        IEnumerable<string?> GenMethodsFromSymbols(IEnumerable<IMethodSymbol> methods)
        {
            foreach (var method in methods)
            {
                if (method.DeclaredAccessibility != Accessibility.Public ||
                    method.MethodKind != MethodKind.Ordinary)
                {
                    continue;
                }
                
                var returnTypeSymbol = method.ReturnType;
                var taskSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task");
                var taskOfTSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.Task`1");
                var valueTaskSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.ValueTask");
                var valueTaskOfTSymbol = compilation.GetTypeByMetadataName("System.Threading.Tasks.ValueTask`1");

                if (returnTypeSymbol.OriginalDefinition.Equals(
                        taskSymbol, SymbolEqualityComparer.IncludeNullability) ||
                    returnTypeSymbol.OriginalDefinition.Equals(
                        valueTaskSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateAffUnitMethodFromSymbol(method)}";
                }
                else if (returnTypeSymbol.OriginalDefinition.Equals(
                             taskOfTSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateAffOfTMethodFromSymbol(method)}";
                }
                else if (returnTypeSymbol.OriginalDefinition.Equals(
                             valueTaskOfTSymbol, SymbolEqualityComparer.IncludeNullability))
                {
                    yield return $"public {CreateAffOfTMethodFromSymbol(method)}";
                }
                else if (returnTypeSymbol.SpecialType == SpecialType.System_Void)
                {
                    yield return $"public {CreateEffUnitMethodFromSymbol(method)}";
                }
                else if (IsObjectMethodFromSymbol(method))
                {
                    continue;
                }
                else if (!IsAnnotatedWithPureAttribute(method))
                {
                    yield return $"public {CreateEffOfTMethodFromSymbol(method)}";
                }
                else
                {
                    yield return $"public {CreateNonEffMethodFromSymbol(method)}";
                }
            }
        }
        
        bool IsAnnotatedWithPureAttribute(IMethodSymbol methodSymbol)
        {
            var pureAttribute = compilation.GetTypeByMetadataName("PureAttribute");
            return methodSymbol.GetAttributes().Any(a => a.AttributeClass.Equals(pureAttribute));
        }
        
        bool IsObjectMethodFromSymbol(IMethodSymbol methodSymbol)
        {
            var objectType = compilation.GetTypeByMetadataName("System.Object");
            var isObjectMethod =
                objectType?.GetMembers(methodSymbol.Name)
                           .OfType<IMethodSymbol>()
                           .Any();
            
            return isObjectMethod ?? false;
        }
        
        string CreateEffUnitMethodFromSymbol(IMethodSymbol methodSymbol)
        {
            var declarationParameters = SymbolReader.GetMethodDeclarationParameters(methodSymbol);
            var parameters = SymbolReader.GetMethodCallParameters(methodSymbol);
            var methodGenericParameters = SymbolReader.GetMethodGenericTypeParameters(methodSymbol);

            return
                $"Eff<Unit> {methodSymbol.Name}{methodGenericParameters}({declarationParameters})" + "\n" +
                SymbolReader.GetMethodConstraints(methodSymbol) +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Eff(() => {{ self.dbContext.{methodSymbol.Name}{methodGenericParameters}({parameters}); return unit; }});" + "\n" +
                $"    }}";
        }
        
        string? CreateEffOfTMethodFromSymbol(IMethodSymbol methodSymbol)
        {
            var declarationParameters = SymbolReader.GetMethodDeclarationParameters(methodSymbol);
            var parameters = SymbolReader.GetMethodCallParameters(methodSymbol);
            var returnTypeName = methodSymbol.ReturnType.ToString();
            
            // Check if taskTypeArgument is nullable
            if (methodSymbol.ReturnType.NullableAnnotation == NullableAnnotation.Annotated)
            {
                // If it is nullable, wrap it with Option
                returnTypeName = $"Option<{returnTypeName.TrimEnd('?')}>";
            }
            
            var methodGenericTypeParameters = SymbolReader.GetMethodGenericTypeParameters(methodSymbol);
            
            return
                $"Eff<{returnTypeName}> {methodSymbol.Name}" +
                $"{methodGenericTypeParameters}({declarationParameters})" + "\n" +
                SymbolReader.GetMethodConstraints(methodSymbol) +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Eff<{returnTypeName}>(() => self.dbContext.{methodSymbol.Name}" +
                $"{methodGenericTypeParameters}({parameters}));" + "\n" +
                $"    }}";
        }

        string CreateNonEffMethodFromSymbol(IMethodSymbol methodSymbol)
        {
            var declarationParameters = SymbolReader.GetMethodDeclarationParameters(methodSymbol);
            var parameters = SymbolReader.GetMethodCallParameters(methodSymbol);
            var methodGenericParameters = SymbolReader.GetMethodGenericTypeParameters(methodSymbol);
            var returnTypeName = methodSymbol.ReturnType.ToString();
                
            return
                $"{returnTypeName} {methodSymbol.Name}{methodGenericParameters}({declarationParameters})" + "\n" +
                SymbolReader.GetMethodConstraints(methodSymbol) +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return self.dbContext.{methodSymbol.Name}{methodGenericParameters}({parameters});" + "\n" +
                $"    }}";
        }
        
        string CreateAffUnitMethodFromSymbol(IMethodSymbol methodSymbol)
        {
            var declarationParameters = SymbolReader.GetMethodDeclarationParameters(methodSymbol);
            var parameters = SymbolReader.GetMethodCallParameters(methodSymbol);
            var methodGenericParameters = SymbolReader.GetMethodGenericTypeParameters(methodSymbol);

            return
                $"Aff<Unit> {methodSymbol.Name}{methodGenericParameters}({declarationParameters})" + "\n" +
                SymbolReader.GetMethodConstraints(methodSymbol) +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Aff(async () => {{ await self.dbContext.{methodSymbol.Name}" +
                $"{methodGenericParameters}({parameters});" +
                $" return unit; }});" + "\n" +
                $"    }}";
        }
        
        string? CreateAffOfTMethodFromSymbol(IMethodSymbol methodSymbol)
        {
            var declarationParameters = SymbolReader.GetMethodDeclarationParameters(methodSymbol);
            var parameters = SymbolReader.GetMethodCallParameters(methodSymbol);

            // Get the return type of the method
            var returnTypeSymbol = methodSymbol.ReturnType;
            
            if (returnTypeSymbol is not INamedTypeSymbol { TypeArguments.Length: > 0 } namedTypeSymbol) return null;
            var taskTypeArgument = namedTypeSymbol.TypeArguments[0];

            var taskTypeArgumentName =
                taskTypeArgument is INamedTypeSymbol { TypeArguments.Length: > 0 } taskTypeArgumentSymbol
                    ? SymbolReader.GetInnerGenericTypes(taskTypeArgumentSymbol)
                    : namedTypeSymbol.TypeArguments[0].Name; // This will be "T" for Task<T>
            
            // Check if taskTypeArgument is nullable
            if (taskTypeArgument.NullableAnnotation == NullableAnnotation.Annotated)
            {
                // If it is nullable, wrap it with Option
                taskTypeArgumentName = $"Option<{taskTypeArgument.Name.TrimEnd('?')}>";
            }
            
            var methodGenericTypeParameters = SymbolReader.GetMethodGenericTypeParameters(methodSymbol);
            
            return
                $"Aff<{taskTypeArgumentName}> {methodSymbol.Name}" +
                $"{methodGenericTypeParameters}({declarationParameters})" + "\n" +
                SymbolReader.GetMethodConstraints(methodSymbol) +
                $"    {{" + "\n" +
                $"        var self = this;" + "\n" +
                $"        return Aff<{taskTypeArgumentName}>(async () => await self.dbContext.{methodSymbol.Name}" +
                $"{methodGenericTypeParameters}({parameters}));" + "\n" +
                $"    }}";
        }
    }
}